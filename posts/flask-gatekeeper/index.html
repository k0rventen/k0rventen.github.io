<!doctype html><html lang=en><head><title>Gatekeeper, a ban & rate limit lib for flask ::</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Avoid bursting and brute forcing on your flask app, with RFC6585 compliance
what &amp;amp; why Rate limiting is a powerful way to restrict the use of a given service by allowing a given rate of requests. Banning on the other hand can be used to block malicious attacks, mainly brute forcing on authentification routes.
The Flask framework does not provide these functionnalities natively (which is normal, it&amp;rsquo;s a WSGI app constructor) but we can create a module to perform these features through flask&amp;rsquo;s primitives."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/flask-gatekeeper/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Gatekeeper, a ban & rate limit lib for flask"><meta name=twitter:description content="Avoid bursting and brute forcing on your flask app"><meta property="og:title" content="Gatekeeper, a ban & rate limit lib for flask"><meta property="og:description" content="Avoid bursting and brute forcing on your flask app"><meta property="og:type" content="article"><meta property="og:url" content="/posts/flask-gatekeeper/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-27T00:00:00+00:00"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>k0rventen:~</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/manpage>manpage</a></li><li><a href=/>posts</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/manpage>manpage</a></li><li><a href=/>posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Gatekeeper, a ban & rate limit lib for flask</h1><div class=post-meta><span class=post-date>2022-06-27</span>
<span class=post-read-time>— 4 min read</span></div><span class=post-tags><a href=/tags/python/>#python</a>&nbsp;
<a href=/tags/flask/>#flask</a>&nbsp;
<a href=/tags/module/>#module</a>&nbsp;</span><div class=post-content><p><em>Avoid bursting and brute forcing on your flask app, with RFC6585 compliance</em></p><h1 id=what--why>what & why</h1><p>Rate limiting is a powerful way to restrict the use of a given service by allowing a given rate of requests.
Banning on the other hand can be used to block malicious attacks, mainly brute forcing on authentification routes.</p><p>The Flask framework does not provide these functionnalities natively (which is normal, it&rsquo;s a WSGI app constructor) but we can create a module to perform these features through flask&rsquo;s primitives.</p><p>The goal is to create a simple module that can:</p><ul><li>rate limit all or any given subset of routes exposed by flask,</li><li>ban IPs based on their behavior,</li><li>support running behind a reverse proxy (when the client IP is the proxy&rsquo;s, and the real client IP is somewhere in the headers)</li></ul><h1 id=how>how</h1><p>Enter <code>Flask-gatekeeper</code>. It answers all the needs depicted above, but beware that it has some notable tradeoffs, mainly the fact that it&rsquo;s a stateless module.</p><p>Let&rsquo;s have a look on how to use the module. We&rsquo;ll first initialize it alongside our flask app:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>gk <span style=color:#f92672>=</span> GateKeeper(app, <span style=color:#75715e># or use .init_app(app) later </span>
</span></span><span style=display:flex><span>                ip_header<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;x-my-ip&#34;</span>, <span style=color:#75715e># optionnal header to use for the client IP (e.g if using a reverse proxy)</span>
</span></span><span style=display:flex><span>                ban_rule<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;count&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#34;window&#34;</span>:<span style=color:#ae81ff>10</span>,<span style=color:#e6db74>&#34;duration&#34;</span>:<span style=color:#ae81ff>600</span>}, <span style=color:#75715e># 3 reports in a 10s window will ban for 600s</span>
</span></span><span style=display:flex><span>                rate_limit_rules<span style=color:#f92672>=</span>[{<span style=color:#e6db74>&#34;count&#34;</span>:<span style=color:#ae81ff>20</span>,<span style=color:#e6db74>&#34;window&#34;</span>:<span style=color:#ae81ff>1</span>},{<span style=color:#e6db74>&#34;count&#34;</span>:<span style=color:#ae81ff>100</span>,<span style=color:#e6db74>&#34;window&#34;</span>:<span style=color:#ae81ff>10</span>}], <span style=color:#75715e># rate limiting will be applied if over 20 requests in 1s or 100 requests in 10s</span>
</span></span><span style=display:flex><span>                excluded_methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;HEAD&#34;</span>]) <span style=color:#75715e># do not add HEAD requests to the tally </span>
</span></span></code></pre></div><p>The <code>GateKeeper</code> constructor takes somes self explanatory arguments that will configure the main instance.
If running behind a reverse proxy, we can supply the header that will contain the IP of the og client (<code>X-Real-IP</code> if its Nginx for example)
All requests will be added to the tally per client, including HEAD or OPTIONS requests. We can ignore specific methods using the <code>excluded_methods</code> arg.</p><p>Then when we define routes, they will by default be subject to the rate limiting applied by the GateKeeper we defined above.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#34;/ping&#34;</span>) <span style=color:#75715e># this route is rate limited by the global rule</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ping</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ok&#34;</span>,<span style=color:#ae81ff>200</span>
</span></span></code></pre></div><p>If we do not want to apply any rate limiting on a givern route, we can decorate the route as such:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#34;/bypass&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@gk</span><span style=color:#f92672>.</span>bypass <span style=color:#75715e># do not apply anything on that route</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bypass</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ok&#34;</span>,<span style=color:#ae81ff>200</span>
</span></span></code></pre></div><p>Some routes might need additional, stricter rate limiting. In this case, we can define new rate limiting rules to be added on top on the ones we defined above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#34;/global_plus_specific&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@gk</span><span style=color:#f92672>.</span>specific(rate_limit_rules<span style=color:#f92672>=</span>[{<span style=color:#e6db74>&#34;count&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#34;window&#34;</span>:<span style=color:#ae81ff>2</span>}]) <span style=color:#75715e># add another rate limit on top of the global one (to avoid bursting for example)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>specific</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ok&#34;</span>,<span style=color:#ae81ff>200</span>
</span></span></code></pre></div><p>We might want specific rate limiting for specific routes, for example a broader rule:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#34;/standalone&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@gk</span><span style=color:#f92672>.</span>specific(rate_limit_rules<span style=color:#f92672>=</span>[{<span style=color:#e6db74>&#34;count&#34;</span>:<span style=color:#ae81ff>10</span>,<span style=color:#e6db74>&#34;window&#34;</span>:<span style=color:#ae81ff>3600</span>}],standalone<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>) <span style=color:#75715e># rate limited only by this rule</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>standalone</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ok&#34;</span>,<span style=color:#ae81ff>200</span>
</span></span></code></pre></div><p>Finally, we can control when IPs are banned using the <code>.report()</code> method.
A generic use case would be to report the IP if the authentification failed, and it will be banned whenever the number of tries surpasses our rule.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>route(<span style=color:#e6db74>&#34;/login&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>login</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> request<span style=color:#f92672>.</span>json<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;password&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;password&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> token,<span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        gk<span style=color:#f92672>.</span>report() <span style=color:#75715e># report the request&#39;s IP, after 3 reports in this case the IP will be banned </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;bad password&#34;</span>,<span style=color:#ae81ff>401</span>
</span></span></code></pre></div><p>Let&rsquo;s launch our app and try a few endpoints to see how it works. Note that the shell being used is fish, and some outputs are truncated for readability.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>(</span>seq 11<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  http get :5000/standalone
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HTTP/1.1 <span style=color:#ae81ff>429</span> TOO MANY REQUESTS
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>Content-Length: <span style=color:#ae81ff>72</span>
</span></span><span style=display:flex><span>Content-Type: text/html; charset<span style=color:#f92672>=</span>utf-8
</span></span><span style=display:flex><span>Date: Mon, <span style=color:#ae81ff>27</span> Jun <span style=color:#ae81ff>2022</span> 18:56:38 GMT
</span></span><span style=display:flex><span>Retry-After: <span style=color:#ae81ff>3441</span>
</span></span><span style=display:flex><span>Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ip 127.0.0.1 rate limited <span style=color:#66d9ef>for</span> 3441s <span style=color:#f92672>(</span>over <span style=color:#ae81ff>10</span> requests in a 3600s window<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>When the rate limiting applies, as per the <a href=https://datatracker.ietf.org/doc/html/rfc6585#section-4>RFC6585</a>, a HTTP code 429 is returned, with the <code>Retry-After</code> header containing in seconds the time to wait, and a short explanation present in the body.</p><p>Now let&rsquo;s try the banning:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>for</span> i in <span style=color:#f92672>(</span>seq 4<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  http get :5000/login password<span style=color:#f92672>=</span>notthegoodpwd
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HTTP/1.1 <span style=color:#ae81ff>401</span> UNAUTHORIZED
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>Content-Length: <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>Content-Type: text/html; charset<span style=color:#f92672>=</span>utf-8
</span></span><span style=display:flex><span>Date: Mon, <span style=color:#ae81ff>27</span> Jun <span style=color:#ae81ff>2022</span> 19:02:31 GMT
</span></span><span style=display:flex><span>Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bad password
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HTTP/1.1 <span style=color:#ae81ff>403</span> FORBIDDEN
</span></span><span style=display:flex><span>Connection: close
</span></span><span style=display:flex><span>Content-Length: <span style=color:#ae81ff>63</span>
</span></span><span style=display:flex><span>Content-Type: text/html; charset<span style=color:#f92672>=</span>utf-8
</span></span><span style=display:flex><span>Date: Mon, <span style=color:#ae81ff>27</span> Jun <span style=color:#ae81ff>2022</span> 19:02:34 GMT
</span></span><span style=display:flex><span>Retry-After: <span style=color:#ae81ff>596</span>
</span></span><span style=display:flex><span>Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ip 127.0.0.1 banned <span style=color:#66d9ef>for</span> 596s <span style=color:#f92672>(</span>reported <span style=color:#ae81ff>3</span> times in a 10s window<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>After 3 failed attempt, the default <code>401</code> reply is short-circuited by GateKeeper and a <code>403</code> is sent instead. As for the rate limiting, a short explanation is sent through the body, alongside a <code>Retry-After</code> header.</p><p>To give it a try or check the documentation, the module is available on <a href=https://pypi.org/project/flask-gatekeeper/>PyPi</a>, the code <a href=https://github.com/k0rventen/flask-gatekeeper>here</a> on Github.</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/kube-user/><span class=button__icon>←</span>
<span class=button__text>Add a new external user (or bot) in k8s</span></a></span>
<span class="button next"><a href=/posts/keda-autoscaling/><span class=button__text>Autoscaling using KEDA</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>k0rventen:~</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div></body></html>