<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Gatekeeper, a ban &amp; rate limit lib for flask | k0rventen&#39;s blog</title>
<meta name="keywords" content="python, flask, module">
<meta name="description" content="Avoid bursting and brute forcing on your flask app">
<meta name="author" content="">
<link rel="canonical" href="/posts/flask-gatekeeper/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/flask-gatekeeper/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="/posts/flask-gatekeeper/">
  <meta property="og:site_name" content="k0rventen&#39;s blog">
  <meta property="og:title" content="Gatekeeper, a ban & rate limit lib for flask">
  <meta property="og:description" content="Avoid bursting and brute forcing on your flask app">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-06-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-06-27T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Flask">
    <meta property="article:tag" content="Module">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gatekeeper, a ban &amp; rate limit lib for flask">
<meta name="twitter:description" content="Avoid bursting and brute forcing on your flask app">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Gatekeeper, a ban \u0026 rate limit lib for flask",
      "item": "/posts/flask-gatekeeper/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Gatekeeper, a ban \u0026 rate limit lib for flask",
  "name": "Gatekeeper, a ban \u0026 rate limit lib for flask",
  "description": "Avoid bursting and brute forcing on your flask app",
  "keywords": [
    "python", "flask", "module"
  ],
  "articleBody": "Avoid bursting and brute forcing on your flask app, with RFC6585 compliance\nwhat \u0026 why Rate limiting is a powerful way to restrict the use of a given service by allowing a given rate of requests. Banning on the other hand can be used to block malicious attacks, mainly brute forcing on authentification routes.\nThe Flask framework does not provide these functionnalities natively (which is normal, it’s a WSGI app constructor) but we can create a module to perform these features through flask’s primitives.\nThe goal is to create a simple module that can:\nrate limit all or any given subset of routes exposed by flask, ban IPs based on their behavior, support running behind a reverse proxy (when the client IP is the proxy’s, and the real client IP is somewhere in the headers) how Enter Flask-gatekeeper. It answers all the needs depicted above, but beware that it has some notable tradeoffs, mainly the fact that it’s a stateless module.\nLet’s have a look on how to use the module. We’ll first initialize it alongside our flask app:\napp = Flask(__name__) gk = GateKeeper(app, # or use .init_app(app) later ip_header=\"x-my-ip\", # optionnal header to use for the client IP (e.g if using a reverse proxy) ban_rule={\"count\":3,\"window\":10,\"duration\":600}, # 3 reports in a 10s window will ban for 600s rate_limit_rules=[{\"count\":20,\"window\":1},{\"count\":100,\"window\":10}], # rate limiting will be applied if over 20 requests in 1s or 100 requests in 10s excluded_methods=[\"HEAD\"]) # do not add HEAD requests to the tally The GateKeeper constructor takes somes self explanatory arguments that will configure the main instance. If running behind a reverse proxy, we can supply the header that will contain the IP of the og client (X-Real-IP if its Nginx for example) All requests will be added to the tally per client, including HEAD or OPTIONS requests. We can ignore specific methods using the excluded_methods arg.\nThen when we define routes, they will by default be subject to the rate limiting applied by the GateKeeper we defined above.\n@app.route(\"/ping\") # this route is rate limited by the global rule def ping(): return \"ok\",200 If we do not want to apply any rate limiting on a givern route, we can decorate the route as such:\n@app.route(\"/bypass\") @gk.bypass # do not apply anything on that route def bypass(): return \"ok\",200 Some routes might need additional, stricter rate limiting. In this case, we can define new rate limiting rules to be added on top on the ones we defined above:\n@app.route(\"/global_plus_specific\") @gk.specific(rate_limit_rules=[{\"count\":1,\"window\":2}]) # add another rate limit on top of the global one (to avoid bursting for example) def specific(): return \"ok\",200 We might want specific rate limiting for specific routes, for example a broader rule:\n@app.route(\"/standalone\") @gk.specific(rate_limit_rules=[{\"count\":10,\"window\":3600}],standalone=True) # rate limited only by this rule def standalone(): return \"ok\",200 Finally, we can control when IPs are banned using the .report() method. A generic use case would be to report the IP if the authentification failed, and it will be banned whenever the number of tries surpasses our rule.\n@app.route(\"/login\") def login(): if request.json.get(\"password\") == \"password\": return token,200 else: gk.report() # report the request's IP, after 3 reports in this case the IP will be banned return \"bad password\",401 Let’s launch our app and try a few endpoints to see how it works. Note that the shell being used is fish, and some outputs are truncated for readability.\nfor i in (seq 11) http get :5000/standalone end [...] HTTP/1.1 429 TOO MANY REQUESTS Connection: close Content-Length: 72 Content-Type: text/html; charset=utf-8 Date: Mon, 27 Jun 2022 18:56:38 GMT Retry-After: 3441 Server: Werkzeug/2.1.2 Python/3.10.4 ip 127.0.0.1 rate limited for 3441s (over 10 requests in a 3600s window) When the rate limiting applies, as per the RFC6585, a HTTP code 429 is returned, with the Retry-After header containing in seconds the time to wait, and a short explanation present in the body.\nNow let’s try the banning:\nfor i in (seq 4) http get :5000/login password=notthegoodpwd end HTTP/1.1 401 UNAUTHORIZED Connection: close Content-Length: 12 Content-Type: text/html; charset=utf-8 Date: Mon, 27 Jun 2022 19:02:31 GMT Server: Werkzeug/2.1.2 Python/3.10.4 bad password [...] HTTP/1.1 403 FORBIDDEN Connection: close Content-Length: 63 Content-Type: text/html; charset=utf-8 Date: Mon, 27 Jun 2022 19:02:34 GMT Retry-After: 596 Server: Werkzeug/2.1.2 Python/3.10.4 ip 127.0.0.1 banned for 596s (reported 3 times in a 10s window) After 3 failed attempt, the default 401 reply is short-circuited by GateKeeper and a 403 is sent instead. As for the rate limiting, a short explanation is sent through the body, alongside a Retry-After header.\nTo give it a try or check the documentation, the module is available on PyPi, the code here on Github.\n",
  "wordCount" : "766",
  "inLanguage": "en",
  "datePublished": "2022-06-27T00:00:00Z",
  "dateModified": "2022-06-27T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/flask-gatekeeper/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "k0rventen's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="&gt; k0rventen: ~ (Alt + H)">&gt; k0rventen: ~</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/links" title="links">
                    <span>links</span>
                </a>
            </li>
            <li>
                <a href="/posts" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Gatekeeper, a ban &amp; rate limit lib for flask
    </h1>
    <div class="post-description">
      Avoid bursting and brute forcing on your flask app
    </div>
    <div class="post-meta"><span title='2022-06-27 00:00:00 +0000 UTC'>June 27, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;766 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents"></nav>
        </div>
    </details>
</div>

  <div class="post-content"><p><em>Avoid bursting and brute forcing on your flask app, with RFC6585 compliance</em></p>
<h1 id="what--why">what &amp; why<a hidden class="anchor" aria-hidden="true" href="#what--why">#</a></h1>
<p>Rate limiting is a powerful way to restrict the use of a given service by allowing a given rate of requests.
Banning on the other hand can be used to block malicious attacks, mainly brute forcing on authentification routes.</p>
<p>The Flask framework does not provide these functionnalities natively (which is normal, it&rsquo;s a WSGI app constructor) but we can create a module to perform these features through flask&rsquo;s primitives.</p>
<p>The goal is to create a simple module that can:</p>
<ul>
<li>rate limit all or any given subset of routes exposed by flask,</li>
<li>ban IPs based on their behavior,</li>
<li>support running behind a reverse proxy (when the client IP is the proxy&rsquo;s, and the real client IP is somewhere in the headers)</li>
</ul>
<h1 id="how">how<a hidden class="anchor" aria-hidden="true" href="#how">#</a></h1>
<p>Enter <code>Flask-gatekeeper</code>. It answers all the needs depicted above, but beware that it has some notable tradeoffs, mainly the fact that it&rsquo;s a stateless module.</p>
<p>Let&rsquo;s have a look on how to use the module. We&rsquo;ll first initialize it alongside our flask app:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">gk</span> <span class="o">=</span> <span class="n">GateKeeper</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="c1"># or use .init_app(app) later </span>
</span></span><span class="line"><span class="cl">                <span class="n">ip_header</span><span class="o">=</span><span class="s2">&#34;x-my-ip&#34;</span><span class="p">,</span> <span class="c1"># optionnal header to use for the client IP (e.g if using a reverse proxy)</span>
</span></span><span class="line"><span class="cl">                <span class="n">ban_rule</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;count&#34;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="s2">&#34;window&#34;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="s2">&#34;duration&#34;</span><span class="p">:</span><span class="mi">600</span><span class="p">},</span> <span class="c1"># 3 reports in a 10s window will ban for 600s</span>
</span></span><span class="line"><span class="cl">                <span class="n">rate_limit_rules</span><span class="o">=</span><span class="p">[{</span><span class="s2">&#34;count&#34;</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span><span class="s2">&#34;window&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">},{</span><span class="s2">&#34;count&#34;</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="s2">&#34;window&#34;</span><span class="p">:</span><span class="mi">10</span><span class="p">}],</span> <span class="c1"># rate limiting will be applied if over 20 requests in 1s or 100 requests in 10s</span>
</span></span><span class="line"><span class="cl">                <span class="n">excluded_methods</span><span class="o">=</span><span class="p">[</span><span class="s2">&#34;HEAD&#34;</span><span class="p">])</span> <span class="c1"># do not add HEAD requests to the tally </span>
</span></span></code></pre></div><p>The <code>GateKeeper</code> constructor takes somes self explanatory arguments that will configure the main instance.
If running behind a reverse proxy, we can supply the header that will contain the IP of the og client (<code>X-Real-IP</code> if its Nginx for example)
All requests will be added to the tally per client, including HEAD or OPTIONS requests. We can ignore specific methods using the <code>excluded_methods</code> arg.</p>
<p>Then when we define routes, they will by default be subject to the rate limiting applied by the GateKeeper we defined above.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&#34;/ping&#34;</span><span class="p">)</span> <span class="c1"># this route is rate limited by the global rule</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ping</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;ok&#34;</span><span class="p">,</span><span class="mi">200</span>
</span></span></code></pre></div><p>If we do not want to apply any rate limiting on a givern route, we can decorate the route as such:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&#34;/bypass&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@gk.bypass</span> <span class="c1"># do not apply anything on that route</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bypass</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;ok&#34;</span><span class="p">,</span><span class="mi">200</span>
</span></span></code></pre></div><p>Some routes might need additional, stricter rate limiting. In this case, we can define new rate limiting rules to be added on top on the ones we defined above:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&#34;/global_plus_specific&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@gk.specific</span><span class="p">(</span><span class="n">rate_limit_rules</span><span class="o">=</span><span class="p">[{</span><span class="s2">&#34;count&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;window&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">}])</span> <span class="c1"># add another rate limit on top of the global one (to avoid bursting for example)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">specific</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;ok&#34;</span><span class="p">,</span><span class="mi">200</span>
</span></span></code></pre></div><p>We might want specific rate limiting for specific routes, for example a broader rule:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&#34;/standalone&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@gk.specific</span><span class="p">(</span><span class="n">rate_limit_rules</span><span class="o">=</span><span class="p">[{</span><span class="s2">&#34;count&#34;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="s2">&#34;window&#34;</span><span class="p">:</span><span class="mi">3600</span><span class="p">}],</span><span class="n">standalone</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># rate limited only by this rule</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">standalone</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;ok&#34;</span><span class="p">,</span><span class="mi">200</span>
</span></span></code></pre></div><p>Finally, we can control when IPs are banned using the <code>.report()</code> method.
A generic use case would be to report the IP if the authentification failed, and it will be banned whenever the number of tries surpasses our rule.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&#34;/login&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;password&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&#34;password&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">token</span><span class="p">,</span><span class="mi">200</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">gk</span><span class="o">.</span><span class="n">report</span><span class="p">()</span> <span class="c1"># report the request&#39;s IP, after 3 reports in this case the IP will be banned </span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;bad password&#34;</span><span class="p">,</span><span class="mi">401</span>
</span></span></code></pre></div><p>Let&rsquo;s launch our app and try a few endpoints to see how it works. Note that the shell being used is fish, and some outputs are truncated for readability.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="k">for</span> i in <span class="o">(</span>seq 11<span class="o">)</span>
</span></span><span class="line"><span class="cl">  http get :5000/standalone
</span></span><span class="line"><span class="cl">end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>...<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">429</span> TOO MANY REQUESTS
</span></span><span class="line"><span class="cl">Connection: close
</span></span><span class="line"><span class="cl">Content-Length: <span class="m">72</span>
</span></span><span class="line"><span class="cl">Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
</span></span><span class="line"><span class="cl">Date: Mon, <span class="m">27</span> Jun <span class="m">2022</span> 18:56:38 GMT
</span></span><span class="line"><span class="cl">Retry-After: <span class="m">3441</span>
</span></span><span class="line"><span class="cl">Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ip 127.0.0.1 rate limited <span class="k">for</span> 3441s <span class="o">(</span>over <span class="m">10</span> requests in a 3600s window<span class="o">)</span>
</span></span></code></pre></div><p>When the rate limiting applies, as per the <a href="https://datatracker.ietf.org/doc/html/rfc6585#section-4">RFC6585</a>, a HTTP code 429 is returned, with the <code>Retry-After</code> header containing in seconds the time to wait, and a short explanation present in the body.</p>
<p>Now let&rsquo;s try the banning:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="k">for</span> i in <span class="o">(</span>seq 4<span class="o">)</span>
</span></span><span class="line"><span class="cl">  http get :5000/login <span class="nv">password</span><span class="o">=</span>notthegoodpwd
</span></span><span class="line"><span class="cl">end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">401</span> UNAUTHORIZED
</span></span><span class="line"><span class="cl">Connection: close
</span></span><span class="line"><span class="cl">Content-Length: <span class="m">12</span>
</span></span><span class="line"><span class="cl">Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
</span></span><span class="line"><span class="cl">Date: Mon, <span class="m">27</span> Jun <span class="m">2022</span> 19:02:31 GMT
</span></span><span class="line"><span class="cl">Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bad password
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>...<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">403</span> FORBIDDEN
</span></span><span class="line"><span class="cl">Connection: close
</span></span><span class="line"><span class="cl">Content-Length: <span class="m">63</span>
</span></span><span class="line"><span class="cl">Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
</span></span><span class="line"><span class="cl">Date: Mon, <span class="m">27</span> Jun <span class="m">2022</span> 19:02:34 GMT
</span></span><span class="line"><span class="cl">Retry-After: <span class="m">596</span>
</span></span><span class="line"><span class="cl">Server: Werkzeug/2.1.2 Python/3.10.4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ip 127.0.0.1 banned <span class="k">for</span> 596s <span class="o">(</span>reported <span class="m">3</span> <span class="nb">times</span> in a 10s window<span class="o">)</span>
</span></span></code></pre></div><p>After 3 failed attempt, the default <code>401</code> reply is short-circuited by GateKeeper and a <code>403</code> is sent instead. As for the rate limiting, a short explanation is sent through the body, alongside a <code>Retry-After</code> header.</p>
<p>To give it a try or check the documentation, the module is available on <a href="https://pypi.org/project/flask-gatekeeper/">PyPi</a>, the code <a href="https://github.com/k0rventen/flask-gatekeeper">here</a> on Github.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/python/">Python</a></li>
      <li><a href="/tags/flask/">Flask</a></li>
      <li><a href="/tags/module/">Module</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="/posts/exporting-apple-health-data/">
    <span class="title">« Prev</span>
    <br>
    <span>Exporting Apple Health Data</span>
  </a>
  <a class="next" href="/posts/keda-autoscaling/">
    <span class="title">Next »</span>
    <br>
    <span>Autoscaling using KEDA</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="/">k0rventen&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
