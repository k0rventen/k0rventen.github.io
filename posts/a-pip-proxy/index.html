<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>A PYPI cache proxy to improve our CI workflows | k0rventen&#39;s blog</title>
<meta name="keywords" content="python, pip, ci, nginx">
<meta name="description" content="it&#39;s like VTEC for `pip install` !">
<meta name="author" content="">
<link rel="canonical" href="/posts/a-pip-proxy/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/a-pip-proxy/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="/posts/a-pip-proxy/">
  <meta property="og:site_name" content="k0rventen&#39;s blog">
  <meta property="og:title" content="A PYPI cache proxy to improve our CI workflows">
  <meta property="og:description" content="it&#39;s like VTEC for `pip install` !">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-09-09T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Pip">
    <meta property="article:tag" content="CI">
    <meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A PYPI cache proxy to improve our CI workflows">
<meta name="twitter:description" content="it&#39;s like VTEC for `pip install` !">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "A PYPI cache proxy to improve our CI workflows",
      "item": "/posts/a-pip-proxy/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A PYPI cache proxy to improve our CI workflows",
  "name": "A PYPI cache proxy to improve our CI workflows",
  "description": "it's like VTEC for `pip install` !",
  "keywords": [
    "python", "pip", "ci", "nginx"
  ],
  "articleBody": "what \u0026 why a bit of context At $dayjob, our backend stack is 99% python based, and deployed through containers on k8s clusters. That means that a lot of time spent in our CI is downloading and installing librairies and modules from Pypi, the Python Package Index.\nFor the sake of data sovereignty and integrity, our CI workers are deployed on-prem, using Gitlab Runners. But due to the variety of projects, we are depending on hundreds of various libraries, ranging from fastapi/flask and their related libraries, to more esoteric ones like pysnmp, yang, scrapli, netmiko/paramiko..\nthe problem That leaves us with a significant amount of bandwith ‘dedicated’ to just downloading libraires, some of them being quite heavy (ML/CV like torch or openCV are more than 100Mb in size). And besides our CI workers, our dev envs are also generating containers to use in our test envs. And keeping up with recent versions means downloading even more.\nOur internet provider does not have a gigabit-class fiber for where we are (at least not at a reasonable price), so we are stuck on a ~100Mb/s downlink, shared across 2 companies, and dozens of employees.\nNote: While we use the docker layer system in our CI to cache layers between runs, the cache is not shared across runners, and has to be purged regularly (weekly) to avoid disk issues, lingering layers..\nThis combination produce the following: In a CI stage building a container taking up 90s, the download of the libraries can some time tally up to 30, even 40 seconds. Overall, around 50% of our CI time is just downloading.\nFurthermore, It seems quite wasteful to download again and again the same package from PYPI, putting unnecessary strain on our internet connection, their infrastructure, and everything in between.\nSo the goal is to avoid as much as possible the re-download of packages from internet, and improve the time needed to download heavy packages.\nhow What we’ve deployed is a docker image that acts as a PIP Proxy on the whole LAN, caching packages as they come and serving them locally when asked again.\nThis approach only required a single change in our CI workflow, which meant 0 downtime when deploying it. And everyone on the network can benefit from them if they add a new env var to their environment.\nBefore digging into the solution, there is some downsides to that solution:\nThat adds a new potential point of failure for our CI. If for some reason the proxy isn’t available, pip install will not redirect automatically to the default index URL, and all workflows will be broken The cache size can increase rapidely, so it’s important to keep an eye on that before running into disk issues (leading to problem n°1) Developers using the proxy on a mobile laptop will encounter problems when the laptop isn’t on the same network as the proxy Now onto the actual solution.\nthe proxy/cache container The docker container is a very simple nginx based image, with the following config from this gist:\nnginx.conf # Loosely based on the following: # (note these do not work correctly in 2023) # https://joelkleier.com/blog/2018-04-17-pypi-temporary-cache.html # https://gist.github.com/dctrwatson/5785638#file-nginx-conf # It's also very easy to end up not proxying requests; tests/mitmtest.sh should help verify that # pip installs actually avoid hitting upstream error_log /var/log/nginx/error.log; pid /var/run/nginx.pid; worker_processes auto; events { worker_connections 2048; } http { include /etc/nginx/mime.types; default_type application/octet-stream; sendfile on; tcp_nodelay on; tcp_nopush off; reset_timedout_connection on; server_tokens off; gzip on; gzip_types application/vnd.pypi.simple.v1+json; gzip_proxied any; gzip_vary on; log_format pypi_cache '$remote_addr - $host [$time_local] ' 'request_time=$request_time upstream_time=$upstream_response_time ' 'cache_status=$upstream_cache_status \\t' '$status \"$request\" $body_bytes_sent'; access_log /dev/stdout pypi_cache buffer=64k flush=1s; # Log to file, can be useful for dev # access_log /var/log/nginx/cache.log pypi_cache buffer=64k flush=1s; # Cache 50G worth of packages for up to 6 months proxy_cache_path /var/lib/nginx/pypi levels=1:2 keys_zone=pypi:16m inactive=6M max_size=50G; # Having the same upstream server listed twice allegedly forces nginx to retry # connections and not fail the request immediately. upstream sg_pypi { server pypi.org:443; server pypi.org:443; keepalive 16; } upstream sg_pythonhosted { server files.pythonhosted.org:443; server files.pythonhosted.org:443; keepalive 16; } server { listen 80 default_server; proxy_cache pypi; proxy_cache_key $uri/$http_accept_encoding; proxy_cache_lock on; proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504; proxy_http_version 1.1; proxy_ssl_server_name on; # sub_filter can't apply to gzipped content, so be careful about that add_header X-Pypi-Cache $upstream_cache_status; sub_filter 'https://pypi.org' $scheme://$host; sub_filter 'https://files.pythonhosted.org/packages' $scheme://$host/packages; sub_filter_once off; sub_filter_types application/vnd.pypi.simple.v1+json application/vnd.pypi.simple.v1+html; location / { proxy_set_header Connection \"\"; proxy_set_header Accept-Encoding \"\"; proxy_cache_valid any 5m; proxy_cache_valid 404 1m; proxy_set_header Host pypi.org; proxy_ssl_name pypi.org; proxy_pass https://sg_pypi; proxy_redirect 'https://pypi.org' $scheme://$host; } location ^~ /simple { proxy_set_header Connection \"\"; proxy_set_header Accept-Encoding \"\"; proxy_cache_valid any 5m; proxy_cache_valid 404 1m; proxy_set_header Host pypi.org; proxy_pass https://sg_pypi; proxy_redirect 'https://pypi.org' $scheme://$host; } location ^~ /packages { proxy_set_header Connection \"\"; proxy_set_header Accept-Encoding \"\"; proxy_cache_valid any 1M; proxy_cache_valid 404 1m; proxy_set_header Host files.pythonhosted.org; proxy_ssl_name files.pythonhosted.org; proxy_pass 'https://sg_pythonhosted/packages'; proxy_redirect 'https://files.pythonhosted.org/packages' $scheme://$host/packages; } } } The Dockerfile is simply the aforementionned conf applied on top of a Nginx container:\nDockerfile FROM nginx:latest RUN mkdir -p /var/lib/nginx/pypi/ /var/log/nginx/ /var/run/ ADD nginx.conf /etc/nginx/nginx.conf Create the container image with docker build -t pip_proxy .. Then create a volume for storing the cached packages docker volumes create pip-cache-data. Then start a container:\ndocker run -d -p 80:80 -v pip-cache-data:/var/lib/nginx/pypi/ pip_proxy If you prefer to deploy this on a Kubernetes cluster :\nk create deployment pip-proxy --image --port 80 k expose deployment pip-proxy --port 80 --target-port 80 k create ingress pip-proxy --rule=\"pip.local.domain.fr/*=pip-proxy:80\" telling pip to use our proxy From pip3 install --help:\nPackage Index Options: -i, --index-url Base URL of the Python Package Index (default https://pypi.org/simple). This should point to a repository compliant with PEP 503 (the simple repository API) or a local directory laid out in the same format. --trusted-host Mark this host or host:port pair as trusted, even though it does not have valid or any HTTPS. This means we can redirect to another package index, using either the -i argument, or through the PIP_INDEX_URL env var. In case the proxy is using self-signed or non-valid certificates, you can use --trusted-host or the PIP_TRUSTED_HOST env var.\nchanges to the CI In our Gitlab group, under Settings \u003e CI/CD \u003e Variables, we can configure these env vars across all our pipelines:\nHere is an excerpt of a CI stage installing torch:\nBefore, using directly the PYPI repo:\n\u003e time pip install --no-cache torch Collecting torch Downloading torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 619.9/619.9 MB 11.4 MB/s eta 0:00:00 ... real\t5m26.790s user\t1m39.378s sys\t0m38.067s After, using the proxy:\nPIP_INDEX_URL=https://pip.local.domain.fr/simple PIP_TRUSTED_HOST=pip.local.domain.fr \u003e pip install --no-cache torch Looking in indexes: https://pip.local.domain.fr/simple Collecting torch Downloading http://pip.local.domain.fr/packages/8c/4d/17e07377c9c3d1a0c4eb3fde1c7c16b5a0ce6133ddbabc08ceef6b7f2645/torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 619.9/619.9 MB 89.7 MB/s eta 0:00:00 ... real\t2m11.356s user\t1m20.170s sys\t0m32.175s We can see that on the second run, pip downloaded torch from our proxy, leading to an ~8x faster download speed. Some packages weren’t cached, but next time they are being downloaded, our proxy will serve them from its cache, saving even more time.\nFor that particular example, we’ve shaved off more than 3 minutes, or an improvement of ~2.5x time wise ! This is a best-case scenario, with heavy packages, but we’ve seen gains across the board.\nI haven’t been able to measure how many MB (or maybe GB) of packages we haven’t downloaded from PYPI, and therefore how much bandwith we saved, but after only 2 weeks of using the cache, it is now weighting in at around 3.2GB. Speculating that we’ve downloaded the same version of most of these packages at least a few more times, it’s safe to say that we saved tens of GB !\nroot@pip-proxy-54789c97df-jsg95:/# du -sh /var/lib/nginx/pypi/ 3.2G\t/var/lib/nginx/pypi/ Overall, the solution was deployed in less than a few hours. It’s now ‘battletested’ across hundreds of pipelines, has saved us hours of CI time and avoided re-re-re-downloading tens of gigabytes worth of packages from PYPI. Hopefully we’ll never have any issues with it !\n(new post on our CI being broken incoming..)\n",
  "wordCount" : "1318",
  "inLanguage": "en",
  "datePublished": "2023-09-09T00:00:00Z",
  "dateModified": "2023-09-09T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/a-pip-proxy/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "k0rventen's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="&gt; k0rventen: ~ (Alt + H)">&gt; k0rventen: ~</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/links" title="links">
                    <span>links</span>
                </a>
            </li>
            <li>
                <a href="/posts" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      A PYPI cache proxy to improve our CI workflows
    </h1>
    <div class="post-description">
      it&#39;s like VTEC for `pip install` !
    </div>
    <div class="post-meta"><span title='2023-09-09 00:00:00 +0000 UTC'>September 9, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1318 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#what--why">what &amp; why</a>
      <ul>
        <li><a href="#a-bit-of-context">a bit of context</a></li>
        <li><a href="#the-problem">the problem</a></li>
      </ul>
    </li>
    <li><a href="#how">how</a>
      <ul>
        <li><a href="#the-proxycache-container">the proxy/cache container</a></li>
        <li><a href="#telling-pip-to-use-our-proxy">telling pip to use our proxy</a></li>
        <li><a href="#changes-to-the-ci">changes to the CI</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="what--why">what &amp; why<a hidden class="anchor" aria-hidden="true" href="#what--why">#</a></h2>
<h3 id="a-bit-of-context">a bit of context<a hidden class="anchor" aria-hidden="true" href="#a-bit-of-context">#</a></h3>
<p>At $dayjob, our backend stack is 99% python based, and deployed through containers on k8s clusters. That means that a lot of time spent in our CI is downloading and installing librairies and modules from <a href="https://pypi.org">Pypi</a>, the Python Package Index.</p>
<p>For the sake of data sovereignty and integrity, our CI workers are deployed on-prem, using Gitlab Runners. But due to the variety of projects, we are depending on hundreds of various libraries, ranging from fastapi/flask and their related libraries, to more esoteric ones like pysnmp, yang, scrapli, netmiko/paramiko..</p>
<h3 id="the-problem">the problem<a hidden class="anchor" aria-hidden="true" href="#the-problem">#</a></h3>
<p>That leaves us with a significant amount of bandwith &lsquo;dedicated&rsquo; to just downloading libraires, some of them being quite heavy (ML/CV like torch or openCV are more than 100Mb in size). And besides our CI workers, our dev envs are also generating containers to use in our test envs. And keeping up with recent versions means downloading even more.</p>
<p>Our internet provider does not have a gigabit-class fiber for where we are (at least not at a reasonable price), so we are stuck on a ~100Mb/s downlink, shared across 2 companies, and dozens of employees.</p>
<p><em>Note: While we use the docker layer system in our CI to cache layers between runs, the cache is not shared across runners, and has to be purged regularly (weekly) to avoid disk issues, lingering layers..</em></p>
<p>This combination produce the following: In a CI stage building a container taking up 90s, the download of the libraries can some time tally up to 30, even 40 seconds. Overall, around 50% of our CI time is just downloading.</p>
<p>Furthermore, It seems quite wasteful to download again and again the same package from PYPI, putting unnecessary strain on our internet connection, their infrastructure, and everything in between.</p>
<p>So the goal is to avoid as much as possible the re-download of packages from internet, and improve the time needed to download heavy packages.</p>
<h2 id="how">how<a hidden class="anchor" aria-hidden="true" href="#how">#</a></h2>
<p>What we&rsquo;ve deployed is a docker image that acts as a PIP Proxy on the whole LAN, caching packages as they come and serving them locally when asked again.</p>
<p>This approach only required a single change in our CI workflow, which meant 0 downtime when deploying it. And everyone on the network can benefit from them if they add a new env var to their environment.</p>
<p>Before digging into the solution, there is some downsides to that solution:</p>
<ul>
<li>That adds a new potential point of failure for our CI. If for some reason the proxy isn&rsquo;t available, <code>pip install</code> will not redirect automatically to the default index URL, and all workflows will be broken</li>
<li>The cache size can increase rapidely, so it&rsquo;s important to keep an eye on that before running into disk issues (leading to problem n°1)</li>
<li>Developers using the proxy on a <em>mobile</em> laptop will encounter problems when the laptop isn&rsquo;t on the same network as the proxy</li>
</ul>
<p>Now onto the actual solution.</p>
<h3 id="the-proxycache-container">the proxy/cache container<a hidden class="anchor" aria-hidden="true" href="#the-proxycache-container">#</a></h3>
<p>The docker container is a very simple nginx based image, with the following config from <a href="https://github.com/hauntsaninja/nginx_pypi_cache/blob/master/nginx.conf">this gist</a>:</p>
<details >
    <summary><strong>nginx.conf</strong></summary>
        <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># Loosely based on the following:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (note these do not work correctly in 2023)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># https://joelkleier.com/blog/2018-04-17-pypi-temporary-cache.html</span>
</span></span><span class="line"><span class="cl"><span class="c1"># https://gist.github.com/dctrwatson/5785638#file-nginx-conf</span>
</span></span><span class="line"><span class="cl"><span class="c1"># It&#39;s also very easy to end up not proxying requests; tests/mitmtest.sh should help verify that</span>
</span></span><span class="line"><span class="cl"><span class="c1"># pip installs actually avoid hitting upstream</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">error_log /var/log/nginx/error.log<span class="p">;</span>
</span></span><span class="line"><span class="cl">pid /var/run/nginx.pid<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">worker_processes auto<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">events <span class="o">{</span>
</span></span><span class="line"><span class="cl">    worker_connections 2048<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">http <span class="o">{</span>
</span></span><span class="line"><span class="cl">    include /etc/nginx/mime.types<span class="p">;</span>
</span></span><span class="line"><span class="cl">    default_type application/octet-stream<span class="p">;</span>
</span></span><span class="line"><span class="cl">    sendfile on<span class="p">;</span>
</span></span><span class="line"><span class="cl">    tcp_nodelay on<span class="p">;</span>
</span></span><span class="line"><span class="cl">    tcp_nopush off<span class="p">;</span>
</span></span><span class="line"><span class="cl">    reset_timedout_connection on<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server_tokens off<span class="p">;</span>
</span></span><span class="line"><span class="cl">    gzip on<span class="p">;</span>
</span></span><span class="line"><span class="cl">    gzip_types application/vnd.pypi.simple.v1+json<span class="p">;</span>
</span></span><span class="line"><span class="cl">    gzip_proxied any<span class="p">;</span>
</span></span><span class="line"><span class="cl">    gzip_vary on<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    log_format pypi_cache <span class="s1">&#39;$remote_addr - $host [$time_local] &#39;</span>
</span></span><span class="line"><span class="cl">                          <span class="s1">&#39;request_time=$request_time upstream_time=$upstream_response_time &#39;</span>
</span></span><span class="line"><span class="cl">                          <span class="s1">&#39;cache_status=$upstream_cache_status \t&#39;</span>
</span></span><span class="line"><span class="cl">                          <span class="s1">&#39;$status &#34;$request&#34; $body_bytes_sent&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    access_log /dev/stdout pypi_cache <span class="nv">buffer</span><span class="o">=</span>64k <span class="nv">flush</span><span class="o">=</span>1s<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Log to file, can be useful for dev</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># access_log /var/log/nginx/cache.log pypi_cache buffer=64k flush=1s;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Cache 50G worth of packages for up to 6 months</span>
</span></span><span class="line"><span class="cl">    proxy_cache_path /var/lib/nginx/pypi <span class="nv">levels</span><span class="o">=</span>1:2 <span class="nv">keys_zone</span><span class="o">=</span>pypi:16m <span class="nv">inactive</span><span class="o">=</span>6M <span class="nv">max_size</span><span class="o">=</span>50G<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Having the same upstream server listed twice allegedly forces nginx to retry</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># connections and not fail the request immediately.</span>
</span></span><span class="line"><span class="cl">    upstream sg_pypi <span class="o">{</span>
</span></span><span class="line"><span class="cl">        server pypi.org:443<span class="p">;</span>
</span></span><span class="line"><span class="cl">        server pypi.org:443<span class="p">;</span>
</span></span><span class="line"><span class="cl">        keepalive 16<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    upstream sg_pythonhosted <span class="o">{</span>
</span></span><span class="line"><span class="cl">        server files.pythonhosted.org:443<span class="p">;</span>
</span></span><span class="line"><span class="cl">        server files.pythonhosted.org:443<span class="p">;</span>
</span></span><span class="line"><span class="cl">        keepalive 16<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    server <span class="o">{</span>
</span></span><span class="line"><span class="cl">        listen <span class="m">80</span> default_server<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        proxy_cache pypi<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_cache_key <span class="nv">$uri</span>/<span class="nv">$http_accept_encoding</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_cache_lock on<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        proxy_http_version 1.1<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_ssl_server_name on<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># sub_filter can&#39;t apply to gzipped content, so be careful about that</span>
</span></span><span class="line"><span class="cl">        add_header X-Pypi-Cache <span class="nv">$upstream_cache_status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        sub_filter <span class="s1">&#39;https://pypi.org&#39;</span> <span class="nv">$scheme</span>://<span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        sub_filter <span class="s1">&#39;https://files.pythonhosted.org/packages&#39;</span> <span class="nv">$scheme</span>://<span class="nv">$host</span>/packages<span class="p">;</span>
</span></span><span class="line"><span class="cl">        sub_filter_once off<span class="p">;</span>
</span></span><span class="line"><span class="cl">        sub_filter_types application/vnd.pypi.simple.v1+json application/vnd.pypi.simple.v1+html<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Connection <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Accept-Encoding <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid any 5m<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid <span class="m">404</span> 1m<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            proxy_set_header Host pypi.org<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_ssl_name pypi.org<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_pass https://sg_pypi<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_redirect <span class="s1">&#39;https://pypi.org&#39;</span> <span class="nv">$scheme</span>://<span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        location ^~ /simple <span class="o">{</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Connection <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Accept-Encoding <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid any 5m<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid <span class="m">404</span> 1m<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            proxy_set_header Host pypi.org<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_pass https://sg_pypi<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_redirect <span class="s1">&#39;https://pypi.org&#39;</span> <span class="nv">$scheme</span>://<span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        location ^~ /packages <span class="o">{</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Connection <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_set_header Accept-Encoding <span class="s2">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid any 1M<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_cache_valid <span class="m">404</span> 1m<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            proxy_set_header Host files.pythonhosted.org<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_ssl_name files.pythonhosted.org<span class="p">;</span>
</span></span><span class="line"><span class="cl">            proxy_pass <span class="s1">&#39;https://sg_pythonhosted/packages&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            proxy_redirect <span class="s1">&#39;https://files.pythonhosted.org/packages&#39;</span> <span class="nv">$scheme</span>://<span class="nv">$host</span>/packages<span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>
</details>


<p>The Dockerfile is simply the aforementionned conf applied on top of a Nginx container:</p>
<details >
    <summary><strong>Dockerfile</strong></summary>
        <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> nginx:latest</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> mkdir -p /var/lib/nginx/pypi/ /var/log/nginx/ /var/run/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ADD</span> nginx.conf /etc/nginx/nginx.conf<span class="err">
</span></span></span></code></pre></div>
</details>


<p>Create the container image with <code>docker build -t pip_proxy .</code>. Then create a volume for storing the cached packages <code>docker volumes create pip-cache-data</code>.
Then start a container:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker run -d -p 80:80 -v pip-cache-data:/var/lib/nginx/pypi/ pip_proxy
</span></span></code></pre></div><p>If you prefer to deploy this on a Kubernetes cluster :</p>
<pre tabindex="0"><code>k create deployment pip-proxy --image &lt;image_tag&gt; --port 80
k expose deployment pip-proxy --port 80 --target-port 80
k create ingress pip-proxy --rule=&#34;pip.local.domain.fr/*=pip-proxy:80&#34;
</code></pre><h3 id="telling-pip-to-use-our-proxy">telling pip to use our proxy<a hidden class="anchor" aria-hidden="true" href="#telling-pip-to-use-our-proxy">#</a></h3>
<p>From <code>pip3 install --help</code>:</p>
<pre tabindex="0"><code>Package Index Options:
  -i, --index-url &lt;url&gt;       Base URL of the Python Package Index (default https://pypi.org/simple). 
                              This should point to a repository compliant with PEP 503 (the simple repository API) 
                              or a local directory laid out in the same format.
  --trusted-host &lt;hostname&gt;   Mark this host or host:port pair as trusted, even though it
                              does not have valid or any HTTPS.
</code></pre><p>This means we can redirect to another package index, using either the <code>-i</code> argument, or through the <strong>PIP_INDEX_URL</strong> env var.
In case the proxy is using self-signed or non-valid certificates, you can use <code>--trusted-host</code> or the <strong>PIP_TRUSTED_HOST</strong> env var.</p>
<h3 id="changes-to-the-ci">changes to the CI<a hidden class="anchor" aria-hidden="true" href="#changes-to-the-ci">#</a></h3>
<p>In our Gitlab group, under Settings &gt; CI/CD &gt; Variables, we can configure these env vars across all our pipelines:</p>
<p><img alt="gitlab env var management" loading="lazy" src="/pip-proxy/env-var-gitlab.png"></p>
<p>Here is an excerpt of a CI stage installing torch:</p>
<p>Before, using directly the PYPI repo:</p>
<pre tabindex="0"><code>&gt; time pip install --no-cache torch
Collecting torch
  Downloading torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 619.9/619.9 MB 11.4 MB/s eta 0:00:00
...
real	5m26.790s
user	1m39.378s
sys	0m38.067s
</code></pre><p>After, using the proxy:</p>
<pre tabindex="0"><code>PIP_INDEX_URL=https://pip.local.domain.fr/simple
PIP_TRUSTED_HOST=pip.local.domain.fr
&gt; pip install --no-cache torch
Looking in indexes: https://pip.local.domain.fr/simple
Collecting torch
  Downloading http://pip.local.domain.fr/packages/8c/4d/17e07377c9c3d1a0c4eb3fde1c7c16b5a0ce6133ddbabc08ceef6b7f2645/torch-2.0.1-cp310-cp310-manylinux1_x86_64.whl (619.9 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 619.9/619.9 MB 89.7 MB/s eta 0:00:00
...
real	2m11.356s
user	1m20.170s
sys	0m32.175s
</code></pre><p>We can see that on the second run, pip downloaded <code>torch</code> from our proxy, leading to an ~8x faster download speed. Some packages weren&rsquo;t cached, but next time they are being downloaded, our proxy will serve them from its cache, saving even more time.</p>
<p>For that particular example, we&rsquo;ve shaved off more than 3 minutes, or an improvement of ~2.5x time wise !
This is a <em>best-case</em> scenario, with heavy packages, but we&rsquo;ve seen gains across the board.</p>
<p>I haven&rsquo;t been able to measure how many MB (or maybe GB) of packages we haven&rsquo;t downloaded from PYPI, and therefore how much bandwith we saved, but after only 2 weeks of using the cache, it is now weighting in at around 3.2GB. Speculating that we&rsquo;ve downloaded the same version of most of these packages at least a few more times, it&rsquo;s safe to say that we saved tens of GB !</p>
<pre tabindex="0"><code>root@pip-proxy-54789c97df-jsg95:/# du -sh /var/lib/nginx/pypi/
3.2G	/var/lib/nginx/pypi/
</code></pre><p>Overall, the solution was deployed in less than a few hours. It&rsquo;s now &lsquo;<em>battletested</em>&rsquo; across hundreds of pipelines, has saved us hours of CI time and avoided re-re-re-downloading tens of gigabytes worth of packages from PYPI. Hopefully we&rsquo;ll never have any issues with it !</p>
<p><em>(new post on our CI being broken incoming..)</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/python/">Python</a></li>
      <li><a href="/tags/pip/">Pip</a></li>
      <li><a href="/tags/ci/">CI</a></li>
      <li><a href="/tags/nginx/">Nginx</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="/posts/watchy/">
    <span class="title">« Prev</span>
    <br>
    <span>An E-Ink watch</span>
  </a>
  <a class="next" href="/posts/reset-password-with-docker/">
    <span class="title">Next »</span>
    <br>
    <span>Reset a lost account password using docker</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="/">k0rventen&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
